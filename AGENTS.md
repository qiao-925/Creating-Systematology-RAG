# AI Agent 协作指南

> **版本**: 2.0（分层重构版）  
> **更新日期**: 2025-11-03  
> **参考文档**: [人机协作范式](agent-task-log/人机协作范式.md)

---

## 📋 目录

- [🔵 前置任务](#前置任务)
  - [方案讨论](#方案讨论)
  - [需求理解与边界分析](#需求理解与边界分析)
- [🟢 任务中的工程实践](#任务中的工程实践)
  - [执行原则](#执行原则)
  - [代码规范](#代码规范)
  - [错误处理与自纠错](#错误处理与自纠错)
  - [协作与决策](#协作与决策)
- [🔴 后置任务](#后置任务)
  - [任务日志管理](#任务日志管理)
  - [测试与验证](#测试与验证)
  - [文档更新](#文档更新)
- [📚 附录](#附录)
  - [项目结构](#项目结构)
  - [语言规范](#语言规范)

---

## 🔵 前置任务

> **执行时机**: 任务开始前必须完成

### 方案讨论

当用户要求"先讨论方案"时：

1. **不要着急修改代码** - 直到方案确定才可以修改代码
2. **充分讨论** - 方案讨论需要在我们双方都没疑问的情况下才可以输出具体方案文档
3. **主动思考边界** - 方案评估请**主动思考需求边界，合理质疑当下方案的完善性**

#### 方案文档必需内容

方案文档**必须包含**以下 4 项内容：

1. **重要逻辑的实现思路**
   - 核心算法或设计模式
   - 关键技术选型理由
   - 关键数据流和状态管理

2. **需求按技术实现的依赖关系拆解并排序**
   - 明确依赖关系（A → B → C）
   - 按依赖顺序排列实施步骤
   - 便于渐进式开发

3. **输出修改或新增文件的路径**
   - 列出所有需要修改的文件
   - 列出所有需要新增的文件
   - 说明每个文件的职责

4. **输出测试要点**
   - 单元测试要点
   - 集成测试要点
   - 边界条件测试
   - 异常情况测试
   - 利于需求完成后的自动化测试

---

### 需求理解与边界分析

在开始实施前，必须：

- ✅ 仔细阅读用户需求，识别核心功能点
- ✅ 明确边界条件和约束
- ✅ 识别潜在风险和问题点
- ✅ 确认是否有可参考的现有业务实现

---

## 🟢 任务中的工程实践

> **执行时机**: 任务执行过程中必须遵守

### 执行原则

#### 1. 严格按步骤执行

- **每次只专注当前讨论的步骤**
- **不允许跨步骤实现功能**或"顺便"完成其他步骤任务
- **每个步骤完成后必须明确汇报**，等待 Review 确认后才能进入下一步

#### 2. 最小改动原则

- **任何代码修改请始终遵守最小改动原则**
- 除非用户明确要求优化或重构
- 避免"顺便"完成其他任务
- 保持代码变更的原子性

#### 3. 参考现有业务

- 代码实现前先思考哪些业务可以参考或复用
- 尽可能参考现有业务的实现风格
- 避免重复造轮子
- 如果不明确可让用户提供参考示例

---

### 代码规范

#### 4. 使用日志代替 print

**强制要求**：所有业务代码必须使用 logging 模块记录日志，禁止使用 print 语句

- 使用内置的 `logging` 模块来记录日志，可以控制日志级别、输出格式和输出位置
- 通过 `src.logger.setup_logger` 创建日志器，统一管理日志配置
- **日志级别选择**：
     - `logger.info()` - 一般信息性消息（如操作成功、进度信息）
     - `logger.warning()` - 警告消息（如降级处理、配置问题）
     - `logger.error()` - 错误消息（如操作失败、异常情况）
     - `logger.debug()` - 调试信息（如详细步骤、调试输出）
- **保留 print 的情况（允许）**：
  - 测试代码中的示例输出（如 `__main__` 块中的测试）
  - 文档示例代码（如 docstring 中的 `>>> print(...)`）
     - 启动脚本中的关键信息输出
- 所有业务逻辑代码必须使用 logger，确保日志可追踪、可配置

#### 5. 使用枚举（Enum）

对于固定的常量集合，使用枚举类型可以使代码更清晰、类型安全

   - 使用 `from enum import Enum` 定义枚举类
   - 枚举值应使用清晰的名称，如 `StrategyType`, `ModuleType`
   - 优先使用枚举替代字符串字面量常量

#### 6. 代码文件行数限制

**强制要求**：所有代码文件不允许超过 300 行

   - 单个文件必须控制在 300 行以内（强制规定）
   - 如果遇到复杂任务，必须拆分成多个文件
   - 拆分原则：按功能模块、职责边界进行合理拆分
   - 目标：保持整个项目的可读性和可维护性

#### 7. 代码注释规范

**强制要求**：在复杂逻辑处添加注释，解释**为什么这样做**，而不是**做什么**

   - 代码本身已经表明在做什么，注释应该解释设计决策和实现原因
- **复杂逻辑包括但不限于**：
     - 算法选择和实现原因
     - 架构设计决策（如延迟初始化、全局缓存等）
     - 异常处理策略（如为什么捕获所有异常、为什么采用保守策略）
     - 性能优化手段（如为什么使用缓存、为什么延迟加载）
     - 兼容性处理（如为什么支持多种接口、为什么采用适配器模式）
- **注释示例**：
     ```python
     # ❌ 不好的注释（只说明做什么）
     # 创建目录
     self.persist_dir.mkdir(parents=True, exist_ok=True)
     
     # ✅ 好的注释（说明为什么这样做）
     # ChromaDB的PersistentClient要求路径必须存在，否则会抛出异常
     # 使用parents=True确保父目录链也被创建，exist_ok=True避免目录已存在时报错
     self.persist_dir.mkdir(parents=True, exist_ok=True)
     ```
- **注释目标**：帮助其他开发者（包括未来的自己）理解代码的设计意图和实现原因

---

### 错误处理与自纠错

#### 8. Bug 修复策略

- **第一次尝试**：根据错误信息直接修复
- **第二次尝试**：如果失败，分析根本原因后再修复
- **超过 2 次失败**：
  - 主动添加关键日志
  - 再次尝试修复
  - 修复完成后主动清除调试日志

#### 9. Agent 自纠错机制

##### 9.1 错误检测

- **语法错误**：使用 `pylint` 用于 Python 代码，`eslint` 用于 JavaScript 代码，在代码执行前进行静态检查
- **逻辑错误**：对每个函数编写单元测试，在关键步骤使用断言
- **运行时错误**：使用 try-except 块捕获异常，检查系统调用返回的错误代码
- **结果验证**：定义验证函数检查输出是否符合预期，检查数据的完整性和一致性

##### 9.2 错误分类

按严重性级别处理：

- **低级**：记录日志，继续执行
- **中级**：尝试自动纠正，最多重试 3 次
- **高级**：停止执行，通知用户

##### 9.3 纠正策略

- **重试策略**：
  - 指数退避：第一次重试等待 1 秒，第二次 2 秒，第三次 4 秒
  - 最大重试次数：3 次
  - 超过 3 次失败应暂停并请求指导（参考"Agent 工作原则"）
- **参数调整**：根据错误信息调整参数，确保参数在合理范围内
- **算法替换**：当主算法失败时，切换到备用算法，提供 2-3 个方案供选择
- **回滚操作**：对于数据库操作执行回滚，恢复到操作前的状态

##### 9.4 重试机制

**重试条件**：
- ✅ **网络错误**：重试（如 Git push、API 调用失败）
- ✅ **资源繁忙**：重试（如文件锁定、数据库连接）
- ❌ **数据错误**：不重试，需要调整数据（如参数错误、配置问题）

**超时控制**：
- 每次重试超时：30 秒
- 总超时时间：不超过 90 秒

---

### 协作与决策

#### 10. 决策原则

**凡是在方案、编码过程遇到任何争议或不确定，必须在第一时间主动告知我由我做决策**

- ❌ 不要默认采用一种方案实现
- ✅ 重大决策必须让我确认
- ✅ 提供 2-3 个方案供选择
- ✅ 解释每个方案的优劣

#### 11. 协作要点

##### Human 应该介入的时刻

1. **方案选择** - 多个可行方案，需要权衡
2. **架构决策** - 影响长期维护
3. **取舍判断** - 例如性能 vs 可维护性
4. **风险评估** - 涉及技术债务或临时方案
5. **超过 3 次失败** - Agent 尝试多次仍未解决

##### Agent 应该自主完成

1. **问题诊断** - 自动尝试多种诊断方法（但失败 3 次需暂停）
2. **代码实现** - 按既定方案执行
3. **测试运行** - 持续验证
4. **文档记录** - 记录过程到 agent-task-log/

##### Agent 工作原则

**应该做的**：
- ✅ 主动尝试多种方案（2-3 次）
- ✅ 记录所有尝试过程（包括失败的）
- ✅ 提供选项而非单一方案
- ✅ 解释思考过程

**不应该做的**：
- ❌ 超过 3 次失败应暂停并请求指导
- ❌ 不要过度生成文档
- ❌ 不要隐藏失败的尝试
- ❌ 重大决策不要独断专行

---

## 🔴 后置任务

> **执行时机**: 任务完成后必须执行

### 任务日志管理

**所有 AI Agent 执行任务的日志文档都必须保存在 `agent-task-log/` 目录中！**

#### 文件命名规范

```
agent-task-log/YYYY-MM-DD-N_任务名称_文档类型.md
```

**示例**：
- `agent-task-log/2025-10-14-1_RAG推理能力增强_快速摘要.md`
- `agent-task-log/2025-10-14-2_UI布局重构_实施总结.md`

#### 文档类型

- **快速摘要** - 任务的简要总结
- **详细过程** - 完整的实施过程记录
- **实施总结** / **完成总结** - 任务完成后的总结（**必须包含优化分析**）
- **实施方案** - 任务实施前的方案设计

#### 禁止行为

- ❌ 禁止在项目根目录创建任务总结文档
- ❌ 禁止在其他目录创建任务日志
- ❌ 禁止使用其他文件命名格式

#### 日志内容要求

任务日志**必须包含**：

- ✅ 任务开始和结束时间
- ✅ 实施的步骤和关键决策
- ✅ 遇到的问题和解决方案
- ✅ 失败的尝试和原因
- ✅ **优化分析**（完成总结类型必须包含，参考 `post-task-optimization.mdc`）

---

### 测试与验证

#### 代码实现后

- ✅ **必须进行基本测试**
- ✅ 至少验证核心功能正常
- ✅ 检查是否有明显错误

#### Bug 修复后

- ✅ 验证修复效果
- ✅ 主动清除调试日志
- ✅ 确保不影响其他功能

---

### 文档更新

以下情况必须更新文档：

- ✅ 修改了 API 接口 → 更新 `docs/API.md`
- ✅ 修改了架构设计 → 更新 `docs/ARCHITECTURE.md`
- ✅ 重大功能变更 → 更新 `README.md` 或 `CHANGELOG.md`
- ✅ 添加新模块 → 更新 `docs/PROJECT_STRUCTURE.md`

---

### 规则文件同步

**⚠️ 全量同步机制：当 AGENTS.md 更新时，必须进行全量同步更新 `.cursor/rules/` 中的对应规则文件**

#### 同步原则

- ✅ **全量同步**：不是部分更新，而是确保 AGENTS.md 的所有章节都有对应的规则文件
- ✅ **全覆盖**：检查映射表中的所有章节，确保都已转换为规则文件
- ✅ **一致性验证**：同步后进行全量验证，确保内容语义一致

#### 同步流程

1. **全量检查映射关系**
   - 对照 `.cursor/rules/AGENTS-MAPPING.md` 中的映射表
   - **检查 AGENTS.md 的所有章节**是否都有对应的规则文件
   - 识别缺失的规则文件
   - 识别需要更新的规则文件

2. **全量更新规则文件**
   - **已有规则文件**：全量更新对应规则文件内容，确保与 AGENTS.md 完全一致
   - **缺失的规则文件**：为未映射的章节创建新的 `.mdc` 规则文件，遵循 MDC 格式
   - **新建章节**：创建新的 `.mdc` 规则文件
   - **更新映射文档**：在 `AGENTS-MAPPING.md` 中更新或添加所有映射关系

3. **全量验证一致性**
   - ✅ 逐一验证每个规则文件与对应 AGENTS.md 章节的内容语义一致
   - ✅ 确保所有规则文件符合 MDC 格式规范
   - ✅ 确保所有规则类型选择正确（Always/Auto Attached/Manual）
   - ✅ 更新 `.cursor/rules/README.md` 规则清单，确保完整

4. **转换原则**
   - **保持语义一致**：结构化规则必须准确反映 AGENTS.md 的意图
   - **增强可执行性**：将自然语言描述转换为可执行的步骤和检查清单
   - **保留原则说明**：在规则文件中引用原始 AGENTS.md 位置，保留上下文
   - **互补而非替代**：结构化规则是对 AGENTS.md 的补充，不是替代

#### 同步时机

- ✅ **立即全量同步**：修改 AGENTS.md 后立即进行全量同步更新所有对应规则文件
- ✅ **验证步骤**：作为代码提交前的必检项，进行全量一致性检查
- ✅ **定期维护**：定期（如每周）进行全量检查，确保两者完全一致

#### 全量同步检查清单

执行同步时必须完成以下检查：

- [ ] 检查映射表：确认 AGENTS.md 的所有主要章节都已映射
- [ ] 检查规则文件：确认所有映射的章节都有对应的规则文件
- [ ] 检查内容一致性：逐一验证规则文件与 AGENTS.md 内容一致
- [ ] 检查格式规范：所有规则文件符合 MDC 格式
- [ ] 检查规则类型：所有规则的类型选择正确
- [ ] 更新映射文档：映射关系完整且准确
- [ ] 更新规则索引：README.md 中的规则清单完整

#### 参考文档

- **映射文档**：`.cursor/rules/AGENTS-MAPPING.md` - 详细的章节映射关系
- **规则索引**：`.cursor/rules/README.md` - 规则文件清单和说明
- **工作流定义**：`.cursor/rules/workflow-definitions.mdc` - 工作流定义指南

---

## 📚 附录

### 项目结构

#### 目录用途

- `agent-task-log/` - **所有AI任务日志文档存放处**（重要！）
- `src/` - 源代码
- `docs/` - 项目文档
- `tests/` - 测试代码
- `data/` - 数据文件
- `pages/` - Streamlit多页面应用

#### 文档更新规则

- 修改代码后，同步更新相关文档（如 ARCHITECTURE.md、API.md 等）
- 重大变更需在 CHANGELOG.md 中记录
- 技术决策需在 DECISIONS.md 中说明

---

### 语言规范

- **Always respond in Chinese-simplified**（始终使用简体中文回复）

---

## 🔗 相关资源

- **结构化规则**: `.cursor/rules/` 目录
- **映射文档**: `.cursor/rules/AGENTS-MAPPING.md`
- **优化分析规则**: `.cursor/rules/post-task-optimization.mdc`
- **人机协作范式**: `agent-task-log/人机协作范式.md`

---

**更新日期**: 2025-11-03  
**版本说明**: 本次重构采用分层结构，按前置任务、任务中、后置任务组织，增强可读性和可执行性
