# 2026-01-24 【plan】进度可视化重构 - 后台线程实时进度

**任务类型**: plan  
**日期**: 2026-01-24  
**任务编号**: #10  
**Agent**: Claude Opus 4.5

---

## Checkpoint 状态表

| CP | 阶段 | 状态 | 完成日期 |
|----|------|------|----------|
| CP1 | build_index 添加进度回调 | ✅ 已完成 | 2026-01-24 |
| CP2 | 创建 ImportTask 后台任务类 | ✅ 已完成 | 2026-01-24 |
| CP3 | 前端轮询组件改造 | ✅ 已完成 | 2026-01-24 |
| CP4 | 集成测试与验收 | ✅ 已完成 | 2026-01-24 |

---

## 背景与目标

### 背景

当前进度可视化实现存在问题：
1. **`ImportProgressManager` 创建但未使用** - 前端 `data_source.py` 创建了进度管理器但没用它
2. **进度条是假的** - 只是固定值跳跃 (0.1 → 0.2 → 0.6 → 0.9 → 1.0)
3. **Streamlit 单线程阻塞** - `build_index()` 执行期间无法更新 UI
4. **耗时最长的阶段无进度** - 索引构建是最耗时的，但前端看不到中间进度

### 目标

实现**真正的实时进度显示**：
1. 后台线程执行导入任务，不阻塞前端
2. 进度管理器实时更新状态（线程安全）
3. 前端轮询获取进度并更新 UI
4. 索引构建阶段显示真实的文档/批次进度

---

## 决策记录

### 决策点：进度更新机制

**背景**：Streamlit 单线程模型限制，无法在同步执行期间更新 UI

**选项**：
1. **后台线程 + 轮询**：任务放后台线程，前端轮询进度
   - 优势：真正实时，用户体验好
   - 劣势：实现复杂度高，需处理线程安全
2. **分批处理 + 重渲染**：分批执行，每批后 `st.rerun()`
   - 优势：实现简单
   - 劣势：每次 rerun 会重置页面状态，体验割裂
3. **SSE/WebSocket**：实时推送
   - 优势：最佳实时性
   - 劣势：Streamlit 原生不支持，需要额外组件

**决策**：选择 **选项 1（后台线程 + 轮询）**

**理由**：
- 提供真正的实时进度体验
- 符合用户期望（方案 A）
- `ImportProgressManager` 已有基础，改造成本可控

**日期**：2026-01-24

---

## 架构设计

```
┌─────────────────────────────────────────────────────────┐
│                    Frontend (Streamlit)                  │
│  ┌─────────────────────────────────────────────────────┐│
│  │  1. 启动任务 → task = ImportTask.start(...)         ││
│  │  2. 轮询循环:                                       ││
│  │     while not task.is_complete:                     ││
│  │       progress = task.get_progress()                ││
│  │       render_progress(progress)                     ││
│  │       time.sleep(0.3)                               ││
│  │       st.rerun()                                    ││
│  └─────────────────────────────────────────────────────┘│
└─────────────────────────────────────────────────────────┘
                           ↓ 读取 (线程安全)
┌─────────────────────────────────────────────────────────┐
│              ImportProgressManager (已有，需增强)         │
│  - current_stage: ImportStage                           │
│  - progress_current / progress_total                    │
│  - logs: List[LogEntry]                                 │
│  - 新增: _lock (threading.Lock)                         │
└─────────────────────────────────────────────────────────┘
                           ↑ 更新 (后台线程)
┌─────────────────────────────────────────────────────────┐
│                   ImportTask (新增)                      │
│  ┌─────────────────────────────────────────────────────┐│
│  │  后台线程执行:                                       ││
│  │  1. preflight()     → pm.start_stage(PREFLIGHT)     ││
│  │  2. git_clone()     → pm.start_stage(GIT_CLONE)     ││
│  │  3. sync_docs()     → pm.start_stage(FILE_WALK)     ││
│  │  4. build_index()   → pm.update_progress(i, total)  ││
│  │  5. save_state()    → pm.complete_import()          ││
│  └─────────────────────────────────────────────────────┘│
└─────────────────────────────────────────────────────────┘
                           ↑ 回调
┌─────────────────────────────────────────────────────────┐
│              build_index() 改造                          │
│  - 新增 progress_callback 参数                          │
│  - 每批次调用回调: callback(current, total)             │
└─────────────────────────────────────────────────────────┘
```

---

## 实施步骤

### CP1: build_index 添加进度回调

**目标**：让 `build_index()` 支持进度回调，外部可感知处理进度

**任务**：
1. 修改 `backend/infrastructure/indexer/build/normal.py`
   - `build_index_normal_mode()` 添加 `progress_callback` 参数
   - 批量插入时每批次调用回调
2. 修改 `backend/infrastructure/indexer/build/builder.py`
   - `build_index_method()` 透传 `progress_callback`
3. 修改 `backend/infrastructure/indexer/core/manager.py`
   - `IndexManager.build_index()` 添加 `progress_callback` 参数
4. 修改 `backend/infrastructure/indexer/service.py`
   - `IndexService.build_index()` 透传参数

**验收标准**：
- [ ] `build_index(docs, progress_callback=lambda cur, total: print(f"{cur}/{total}"))` 可用
- [ ] 回调频率：每 10 个节点更新一次
- [ ] 现有测试通过

**预计文件改动**：
| 文件 | 改动 |
|------|------|
| `indexer/build/normal.py` | 添加回调参数和调用 |
| `indexer/build/builder.py` | 透传回调参数 |
| `indexer/core/manager.py` | 透传回调参数 |
| `indexer/service.py` | 透传回调参数 |

---

### CP2: 创建 ImportTask 后台任务类

**目标**：封装导入任务，支持后台执行和进度查询

**任务**：
1. 新建 `backend/infrastructure/data_loader/import_task.py`
   - `ImportTask` 类
   - `start()` 方法：启动后台线程
   - `get_progress()` 方法：获取当前进度
   - `is_complete` 属性
   - `cancel()` 方法
2. 增强 `ImportProgressManager`（如需）
   - 确保所有方法线程安全
3. 实现完整导入流程：
   - preflight → git_clone → sync_docs → build_index → save_state

**验收标准**：
- [ ] `task = ImportTask.start(owner, repo, branch, ...)` 可用
- [ ] `task.get_progress()` 返回当前进度字典
- [ ] `task.is_complete` 正确反映状态
- [ ] `task.cancel()` 可取消任务

**预计文件改动**：
| 操作 | 文件 | 说明 |
|------|------|------|
| 新增 | `data_loader/import_task.py` | 后台任务类 |
| 修改 | `data_loader/progress.py` | 增强线程安全（如需） |
| 修改 | `data_loader/__init__.py` | 导出新类 |

---

### CP3: 前端轮询组件改造

**目标**：前端使用轮询机制获取实时进度

**任务**：
1. 修改 `frontend/settings/data_source.py`
   - `_handle_add_github_repo()` 改用 `ImportTask`
   - 实现轮询循环
   - 正确处理取消和错误
2. 修改 `frontend/components/import_progress.py`（如需）
   - 确保渲染函数兼容新数据格式

**轮询实现方案**：
```python
# 启动任务
task = ImportTask.start(owner, repo, branch, index_manager, github_sync_manager)
st.session_state['current_import_task'] = task

# 轮询循环（利用 Streamlit rerun 机制）
task = st.session_state.get('current_import_task')
if task and not task.is_complete:
    progress = task.get_progress()
    render_import_progress_from_dict(progress)
    time.sleep(0.3)
    st.rerun()
elif task and task.is_complete:
    # 显示结果
    if task.is_success:
        st.success(f"✅ 导入完成！")
    else:
        st.error(f"❌ 导入失败: {task.error_message}")
    st.session_state['current_import_task'] = None
```

**验收标准**：
- [ ] 进度条实时更新（每 0.3-0.5 秒）
- [ ] 阶段切换正确显示
- [ ] 索引构建阶段显示文档处理进度
- [ ] 取消功能正常
- [ ] 错误正确显示

**预计文件改动**：
| 文件 | 改动 |
|------|------|
| `frontend/settings/data_source.py` | 改用 ImportTask + 轮询 |
| `frontend/components/import_progress.py` | 可能需要调整 |

---

### CP4: 集成测试与验收

**目标**：端到端验证功能正确性

**任务**：
1. 单元测试
   - `ImportTask` 基本功能
   - 进度回调正确触发
2. 集成测试
   - 小仓库导入（如 octocat/Hello-World）
   - 观察进度显示是否实时
3. 边界测试
   - 取消任务
   - 网络错误
   - 仓库不存在

**验收标准**：
- [ ] 进度条平滑更新，无明显卡顿
- [ ] 索引构建阶段能看到 `处理中 15/80` 这样的进度
- [ ] 取消功能正常
- [ ] 错误处理正确
- [ ] 无回归问题

---

## 文件改动清单

| 操作 | 文件 | 说明 |
|------|------|------|
| 修改 | `backend/infrastructure/indexer/build/normal.py` | 添加进度回调 |
| 修改 | `backend/infrastructure/indexer/build/builder.py` | 透传回调参数 |
| 修改 | `backend/infrastructure/indexer/core/manager.py` | 透传回调参数 |
| 修改 | `backend/infrastructure/indexer/service.py` | 透传回调参数 |
| 新增 | `backend/infrastructure/data_loader/import_task.py` | 后台任务类 |
| 修改 | `backend/infrastructure/data_loader/progress.py` | 增强线程安全 |
| 修改 | `backend/infrastructure/data_loader/__init__.py` | 导出新类 |
| 修改 | `frontend/settings/data_source.py` | 轮询机制 |
| 修改 | `frontend/components/import_progress.py` | 可能调整 |

---

## 风险与注意事项

1. **线程安全**：`ImportProgressManager` 的所有方法必须线程安全，特别是 `to_dict()`
2. **Streamlit 重渲染**：`st.rerun()` 会重新执行整个脚本，需要用 `session_state` 保持任务引用
3. **资源清理**：任务完成或取消后，确保后台线程正确终止
4. **向后兼容**：保持 `build_index()` 的默认行为（`progress_callback=None` 时不回调）
5. **轮询频率**：0.3-0.5 秒合适，太快浪费资源，太慢体验差

---

## 下一步

确认计划后，从 **CP1（build_index 添加进度回调）** 开始执行。
