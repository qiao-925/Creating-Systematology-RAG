---
description: 遵循架构规范 - RAG系统架构规范与LlamaIndex使用指南 - 包含模块化设计原则
globs:
  - "src/business/**"
  - "src/query/**"
  - "src/indexer/**"
  - "src/retrievers/**"
  - "src/embeddings/**"
  - "src/data_source/**"
  - "src/rerankers/**"
  - "src/observers/**"
alwaysApply: false
---

# RAG 系统架构规范

## 架构层次

项目采用**三层模块化架构**：

```
前端层（Presentation） → 业务层（Business） → 基础设施层（Infrastructure）
```

### 层次职责

| 层次 | 职责 | 示例 |
|------|------|------|
| **前端层** | 用户交互、界面展示 | `app.py`, `pages/`, `main.py` |
| **业务层** | 核心业务逻辑、流程编排 | `RAGService`, `PipelineExecutor`, `StrategyManager` |
| **基础设施层** | 技术基础设施、资源提供 | `Config`, `Logger`, `Embedding`, `DataSource` |

### 依赖规则
- **前端层** 只调用业务层的 `RAGService`，不直接访问基础设施层
- **业务层** 通过依赖注入获取基础设施层资源
- **基础设施层** 无业务逻辑，只提供服务和资源

---

## LlamaIndex 核心概念

### 1. Document 与 Node
```python
from llama_index.core.schema import Document as LlamaDocument

# Document: 原始文档
doc = LlamaDocument(
    text="文档内容",
    metadata={"source": "file.md", "page": 1}
)

# Node: 分块后的节点（自动创建）
# 使用 SentenceSplitter 分割文档
```

### 2. VectorStoreIndex
```python
from llama_index.core import VectorStoreIndex, StorageContext
from llama_index.vector_stores.chroma import ChromaVectorStore

# 创建向量存储
vector_store = ChromaVectorStore(chroma_collection=collection)

# 创建存储上下文
storage_context = StorageContext.from_defaults(vector_store=vector_store)

# 创建索引
index = VectorStoreIndex.from_documents(
    documents,
    storage_context=storage_context,
    embed_model=embedding_model
)
```

### 3. QueryEngine
```python
from llama_index.core import get_response_synthesizer
from llama_index.core.query_engine import RetrieverQueryEngine

# 创建检索器
retriever = index.as_retriever(similarity_top_k=5)

# 创建响应合成器
response_synthesizer = get_response_synthesizer(
    response_mode="compact",
    llm=llm
)

# 创建查询引擎
query_engine = RetrieverQueryEngine(
    retriever=retriever,
    response_synthesizer=response_synthesizer
)
```

---

## 模块化设计原则

### 1. 单一职责原则
- 每个模块/类只负责一个功能领域
- 避免"上帝类"（God Class）
- 职责边界清晰，易于测试和维护

### 2. 接口隔离
- 定义最小化接口，避免臃肿
- 实现类只实现必需的方法
- 使用组合而非继承

### 3. 开闭原则
- 对扩展开放：通过继承/实现添加新功能
- 对修改封闭：不修改已有稳定代码
- 通过工厂模式创建新实现

### 4. 可插拔架构
- 所有组件通过**抽象基类**定义接口
- 使用**工厂模式**创建实例
- 支持运行时配置切换

### 5. 接口契约
- 定义清晰的接口协议（`BaseEmbedding`, `BaseDataSource`, `BaseRetriever`）
- 所有实现类必须实现接口定义的方法
- 接口变更需要向后兼容或版本管理

### 6. 依赖注入
- 构造函数传递依赖，而非全局单例
- 便于单元测试和模拟
- 避免隐式依赖

```python
class QueryEngine:
    def __init__(
        self,
        index: VectorStoreIndex,
        embedding_model: BaseEmbedding,
        llm: Optional[LLM] = None
    ):
        self.index = index
        self.embedding_model = embedding_model
        self.llm = llm or self._create_default_llm()
```

---

## 模块化实现模式

### 1. 抽象基类模式
```python
from abc import ABC, abstractmethod

class BaseEmbedding(ABC):
    """Embedding抽象基类"""
    
    @abstractmethod
    def embed_query(self, text: str) -> List[float]:
        """向量化查询文本"""
        pass
    
    @abstractmethod
    def embed_documents(self, texts: List[str]) -> List[List[float]]:
        """批量向量化文档"""
        pass
```

### 2. 工厂模式
```python
def create_embedding(embedding_type: str, **kwargs) -> BaseEmbedding:
    """创建Embedding实例"""
    if embedding_type == "local":
        return LocalEmbedding(**kwargs)
    elif embedding_type == "api":
        return APIEmbedding(**kwargs)
    else:
        raise ValueError(f"不支持的类型: {embedding_type}")
```

### 3. 注册表模式（ModuleRegistry）
```python
class ModuleRegistry:
    """模块注册中心"""
    
    _modules: Dict[str, Type] = {}
    
    @classmethod
    def register(cls, name: str, module_class: Type):
        cls._modules[name] = module_class
    
    @classmethod
    def create(cls, name: str, **kwargs):
        module_class = cls._modules.get(name)
        if not module_class:
            raise ValueError(f"未注册的模块: {name}")
        return module_class(**kwargs)
```

---

## 模块分类

### 1. 基础设施模块
位置：`src/embeddings/`, `src/data_source/`, `src/observers/`

特点：
- 提供基础能力，无业务逻辑
- 通过接口定义契约
- 支持可插拔替换

### 2. 业务模块
位置：`src/business/`, `src/query/`, `src/retrievers/`

特点：
- 包含业务逻辑和流程编排
- 通过协议协作
- 依赖注入基础设施资源

### 3. 适配器模块
位置：`src/business/pipeline/adapters.py`

特点：
- 适配不同接口协议
- 桥接新旧架构
- 临时过渡方案

---

## 配置驱动

### 集中配置管理
- 所有配置在 `src/config.py` 中定义
- 环境变量通过 `.env` 文件管理
- 配置变更不需要修改代码

### 配置示例
```python
# .env
EMBEDDING_TYPE=local
EMBEDDING_MODEL=BAAI/bge-small-zh-v1.5
RETRIEVAL_STRATEGY=multi
ENABLED_RETRIEVAL_STRATEGIES=vector,bm25,grep
```

---

## 模块扩展指南

### 添加新 Embedding 实现
1. 在 `src/embeddings/` 创建新文件
2. 继承 `BaseEmbedding`
3. 实现必需方法
4. 在 `factory.py` 中注册

### 添加新数据源
1. 在 `src/data_source/` 创建新文件
2. 继承 `BaseDataSource`
3. 实现 `load()` 方法
4. 在工厂函数中注册

### 添加新检索器
1. 在 `src/retrievers/` 创建新文件
2. 实现 `BaseRetriever` 接口（或使用适配器）
3. 在 `retriever_factory.py` 中注册

---

## 模块间协作

### 协议定义
- 业务模块通过协议定义协作契约
- 协议定义在 `src/business/protocols.py`
- 避免直接依赖具体实现类

### 事件钩子
- 使用观察者模式支持事件钩子
- 模块可注册钩子函数
- 支持扩展点注入

```python
class PipelineExecutor:
    def __init__(self):
        self.hooks: Dict[str, List[Callable]] = {}
    
    def register_hook(self, event: str, callback: Callable):
        self.hooks.setdefault(event, []).append(callback)
    
    def emit(self, event: str, **kwargs):
        for callback in self.hooks.get(event, []):
            callback(**kwargs)
```

---

## 代码拆分原则

当模块超过 300 行时，按以下原则拆分：

1. **按职责拆分**：每个文件一个主要职责
2. **按层次拆分**：接口、实现、工厂分离
3. **按功能拆分**：核心功能、工具函数、适配器分离

示例：`src/indexer.py` 拆分为：
- `indexer/index_core.py` - 核心索引逻辑
- `indexer/index_manager.py` - 索引管理
- `indexer/index_builder.py` - 构建流程
- `indexer/index_utils.py` - 工具函数

---

## 检索策略

项目支持多种检索策略，通过配置切换：

- **vector**: 向量相似度检索（默认）
- **bm25**: BM25 关键词检索
- **hybrid**: 向量 + BM25 混合检索
- **grep**: 正则表达式检索
- **multi**: 多策略融合检索

### 实现要点
- 检索器通过 `retriever_factory.py` 创建
- 支持自定义权重和合并策略
- 结果去重和排序可配置

---

## Embedding 模型管理

### 1. 模型加载
- 使用全局单例缓存，避免重复加载
- 支持强制重新加载（`force_reload=True`）
- 自动检测 GPU/CPU 设备

### 2. 模型切换
```python
# 通过配置切换
EMBEDDING_TYPE=local  # 或 api
EMBEDDING_MODEL=model_name_or_path
```

### 3. 实现要求
- 继承 `BaseEmbedding`
- 实现 `embed_query` 和 `embed_documents` 方法
- 支持批量处理优化

---

## 可观测性集成

### Phoenix 集成
- 使用 `PhoenixObserver` 追踪 RAG 流程
- 记录检索结果、生成过程
- 支持可视化分析

### LlamaDebugHandler
- 集成 `LlamaDebugHandler` 进行调试
- 追踪查询、检索、生成各个阶段
- 记录详细的时间戳和元数据

---

## 参考实现

参考以下文件了解最佳实践：
- `src/query/modular/engine.py` - 模块化查询引擎
- `src/embeddings/factory.py` - Embedding 工厂模式
- `src/business/services/rag_service.py` - RAG 服务统一接口
- `src/indexer/index_manager.py` - 索引管理
- `src/embeddings/` - Embedding 可插拔架构
- `src/query/modular/` - 模块化查询引擎
- `src/business/registry.py` - 模块注册中心
