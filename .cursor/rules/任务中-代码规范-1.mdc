---
description: 遵循代码规范 - Python代码风格与规范
alwaysApply: true
---

# Python 代码风格规范

## 核心原则

### 1. 类型提示（Type Hints）
- **所有函数必须提供类型提示**
- 使用 `typing` 模块（`List`, `Dict`, `Optional`, `Union` 等）
- 返回类型必须明确指定，无返回值使用 `-> None`

```python
from typing import List, Optional, Dict

def process_documents(
    docs: List[Document],
    config: Optional[Dict[str, str]] = None
) -> List[ProcessedDocument]:
    """处理文档列表"""
    pass
```

### 2. 文件行数限制
- **强制要求**：单个代码文件不得超过 300 行
- 超过限制必须拆分成多个模块
- 拆分原则：按功能职责、单一职责原则

### 3. 日志规范（使用日志代替 print）

**强制要求**：所有业务代码必须使用 logging 模块记录日志，禁止使用 print 语句

- 使用内置的 `logging` 模块来记录日志，可以控制日志级别、输出格式和输出位置
- 通过 `src.logger.setup_logger` 创建日志器，统一管理日志配置
- **日志级别选择**：
  - `logger.info()` - 一般信息性消息（如操作成功、进度信息）
  - `logger.warning()` - 警告消息（如降级处理、配置问题）
  - `logger.error()` - 错误消息（如操作失败、异常情况）
  - `logger.debug()` - 调试信息（如详细步骤、调试输出）
- **保留 print 的情况（允许）**：
  - 测试代码中的示例输出（如 `__main__` 块中的测试）
  - 文档示例代码（如 docstring 中的 `>>> print(...)`）
  - 启动脚本中的关键信息输出
- 所有业务逻辑代码必须使用 logger，确保日志可追踪、可配置

```python
from src.logger import setup_logger

logger = setup_logger('module_name')

logger.info("开始处理文档")
logger.error(f"处理失败: {error}", exc_info=True)
```

### 4. 异常处理
- 使用具体的异常类型，避免裸露的 `except:`
- 捕获异常后必须记录日志或重新抛出
- 关键路径必须有异常处理

```python
try:
    result = process_data()
except ValueError as e:
    logger.error(f"数据验证失败: {e}")
    raise
except Exception as e:
    logger.exception("未知错误")
    raise RuntimeError(f"处理失败: {e}") from e
```

### 5. 文档字符串（Docstrings）
- 所有公共函数、类必须有 docstring
- 使用 Google 风格或 NumPy 风格
- 包含参数说明、返回值说明、异常说明

```python
def build_index(
    documents: List[Document],
    vector_store: VectorStore,
    embedding_model: Optional[BaseEmbedding] = None
) -> VectorStoreIndex:
    """构建向量索引
    
    Args:
        documents: 文档列表
        vector_store: 向量存储实例
        embedding_model: Embedding模型，默认使用配置中的模型
        
    Returns:
        VectorStoreIndex: 构建好的索引
        
    Raises:
        ValueError: 当documents为空时抛出
    """
    pass
```

### 6. 文件命名规范

#### 6.1 Python 文件
- **模块文件**：`snake_case.py`（如 `index_manager.py`）
- **测试文件**：`test_*.py`（如 `test_indexer.py`）
- **配置文件**：`config.py`, `settings.py`
- **工具脚本**：`scripts/*.py`

#### 6.2 目录文件
- **特殊文件**：`__init__.py`, `__main__.py`
- **私有模块**：`_internal.py`（单下划线前缀）

### 7. 代码文件组织

#### 7.1 文件结构模板
```python
"""模块说明文档"""

# 1. 标准库导入
import os
from pathlib import Path
from typing import List, Optional

# 2. 第三方库导入
import chromadb
from llama_index.core import VectorStoreIndex

# 3. 本地模块导入
from src.config import config
from src.logger import setup_logger

# 4. 模块级常量
DEFAULT_TOP_K = 10

# 5. 日志器初始化
logger = setup_logger('module_name')

# 6. 类和函数定义
class MyClass:
    """类说明"""
    pass

def my_function():
    """函数说明"""
    pass
```

#### 7.2 代码组织顺序
- 文件顶部：模块 docstring
- 然后是导入（分三部分）
- 然后是常量定义
- 然后是类和函数定义
- `if __name__ == "__main__":` 仅用于测试脚本

### 8. 导入规范
- 标准库 → 第三方库 → 本地模块（三部分，空行分隔）
- 按字母顺序排列
- 避免 `from module import *`
- 相对导入仅用于同包内

```python
# 标准库
import os
from pathlib import Path
from typing import List, Optional

# 第三方库
import chromadb
from llama_index.core import VectorStoreIndex

# 本地模块
from src.config import config
from src.logger import setup_logger
```

### 9. 命名规范
- **类名**：大驼峰（`PascalCase`）：`BaseEmbedding`, `VectorStoreIndex`
- **函数/变量**：蛇形命名（`snake_case`）：`build_index`, `embedding_model`
- **常量**：全大写下划线分隔：`MAX_RETRIES`, `DEFAULT_TOP_K`
- **私有成员**：单下划线前缀：`_internal_method`, `_cache`

### 10. 枚举使用（Enum）
- **对于固定的常量集合，使用枚举类型**
- 使用 `from enum import Enum` 定义枚举类
- 枚举类名使用大驼峰：`StrategyType`, `ModuleType`
- 枚举成员使用全大写或清晰描述：`RETRIEVAL`, `RERANKING`
- 优先使用枚举替代字符串字面量常量，提高类型安全

```python
from enum import Enum

class StrategyType(Enum):
    """策略类型枚举"""
    RETRIEVAL = "retrieval"
    RERANKING = "reranking"
    GENERATION = "generation"

# 使用枚举
strategy = StrategyType.RETRIEVAL
if strategy == StrategyType.RETRIEVAL:
    pass
```

### 11. 代码注释规范

**强制要求**：在复杂逻辑处添加注释，解释**为什么这样做**，而不是**做什么**

- 代码本身已经表明在做什么，注释应该解释设计决策和实现原因
- **复杂逻辑包括但不限于**：
  - 算法选择和实现原因
  - 架构设计决策（如延迟初始化、全局缓存等）
  - 异常处理策略（如为什么捕获所有异常、为什么采用保守策略）
  - 性能优化手段（如为什么使用缓存、为什么延迟加载）
  - 兼容性处理（如为什么支持多种接口、为什么采用适配器模式）
- **注释示例**：
  ```python
  # ❌ 不好的注释（只说明做什么）
  # 创建目录
  self.persist_dir.mkdir(parents=True, exist_ok=True)
  
  # ✅ 好的注释（说明为什么这样做）
  # ChromaDB的PersistentClient要求路径必须存在，否则会抛出异常
  # 使用parents=True确保父目录链也被创建，exist_ok=True避免目录已存在时报错
  self.persist_dir.mkdir(parents=True, exist_ok=True)
  ```
- **注释目标**：帮助其他开发者（包括未来的自己）理解代码的设计意图和实现原因

---

## 参考示例

参考以下文件的代码风格：
- `src/business/protocols.py` - 枚举使用（`ModuleType`）
- `src/business/strategy_manager.py` - 枚举使用（`StrategyType`）
- `src/query/modular/retriever_factory.py` - 工厂模式实现
- `src/embeddings/base.py` - 抽象基类定义
- `src/config.py` - 配置管理