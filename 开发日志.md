# 项目演进路线图

> 从实践中总结的方法论 - 记录思维路径与关键决策

**最后更新**: 2026-01-01

---

## 目录

- [项目愿景与起点](#项目愿景与起点)
- [演进阶段](#演进阶段)
  - [阶段1: MVP构建（10月初）](#阶段1-mvp构建10月初)
  - [阶段2: 功能迭代与重构（10月中旬）](#阶段2-功能迭代与重构10月中旬)
  - [阶段3: 生产部署（10月下旬）](#阶段3-生产部署10月下旬)
  - [阶段4: 架构升级（11月初）](#阶段4-架构升级11月初)
  - [阶段5: 代码质量提升（12月）](#阶段5-代码质量提升12月)
  - [阶段6: 前端架构统一（1月）](#阶段6-前端架构统一1月)
- [当前状态](#当前状态)
  - [已实现的核心功能](#已实现的核心功能)
  - [技术架构现状](#技术架构现状)
  - [项目指标](#项目指标)
- [未来方向探索](#未来方向探索)
  - [短期方向](#短期方向)
  - [中期方向](#中期方向)
  - [长期愿景](#长期愿景)
- [方法论总结](#方法论总结)
  - [技术决策原则](#技术决策原则)
  - [实践中的经验](#实践中的经验)
  - [反思与思考](#反思与思考)

---

## 🎯 项目愿景与起点

### 初心

2025年10月初，在阅读创业系统学相关书籍时，萌生了一个想法：

> "可以在垂直领域（系统科学）做一个类似RAG的应用，正好可以将AI和学习结合起来。"

**核心动机**：
- 想将钱学森先生的系统学思想数字化、智能化
- 探索RAG技术在垂直领域的应用价值
- 在实践中学习AI和系统工程的结合

### 起点

**技术选型思考**：

| 组件 | 选择 | 理由 |
|------|------|------|
| **RAG框架** | LlamaIndex | 专门为RAG设计，功能强大，文档完善 |
| **LLM** | DeepSeek API | 国产优秀模型，性价比高 |
| **向量数据库** | Chroma | 轻量级，易于部署，本地优先 |
| **Web框架** | Streamlit | 快速构建，开发效率高 |
| **Embedding** | BGE-base-zh-v1.5 | 中文效果好，支持本地部署 |

**设计原则**：
1. **奥卡姆剃刀原则** - 简洁优于复杂
2. **最小改动原则** - 渐进式开发
3. **用户优先** - 一切以用户体验为出发点

---

## 🚀 演进阶段

### 阶段1: MVP构建（10月初）

**时间线**：2025-10-07 至 2025-10-09

#### 核心目标

构建一个功能完整的RAG系统MVP，验证技术栈可行性和基础功能。

#### 关键决策

**决策1：模块划分**
- 采用传统分层架构：配置→数据→索引→查询→对话
- 每个模块职责单一，便于独立测试

**决策2：测试优先**
- 88个测试用例（单元/集成/性能）
- Mock策略：隔离外部依赖（DeepSeek API、Chroma）

**决策3：DeepSeek集成**
- 问题：LlamaIndex不原生支持DeepSeek模型名
- 解决：模块级Monkey Patch
- **经验**：模块导入时patch最有效，需同时patch多个引用点

#### 遇到的问题

**问题1：第三方库兼容性问题**
- DeepSeek不被LlamaIndex官方支持
- 需要Monkey Patch才能在测试中正常运行
- **教训**：选择技术栈时考虑兼容性，预留扩展机制

**问题2：编码与Mock优化**
- Windows环境下的编码问题
- 网络依赖需要Mock
- **经验**：充分Mock可大幅提高测试稳定性和速度

#### 经验总结

1. **测试驱动开发** - 先写测试，再实现功能，反向约束代码质量
2. **Mock要适度** - 只Mock网络调用，不要过度抽象
3. **模块级Patching** - 比函数级Patching更稳定
4. **97.7%通过率已足够** - 不必追求100%，要平衡时间与收益

#### 里程碑

- ✅ 核心RAG流程完整：文档加载→索引构建→查询生成
- ✅ 引用溯源功能实现
- ✅ 多轮对话支持
- ✅ 测试体系建立
- ✅ 文档框架搭建

---

### 阶段2: 功能迭代与重构（10月中旬）

**时间线**：2025-10-10 至 2025-10-15

#### 核心目标

扩展数据源能力，优化用户体验，提升系统鲁棒性。

#### 关键决策

**决策1：GitHub数据源集成**
- 增量更新设计：首次全量，后续增量（30倍性能提升）
- 架构重构：GitHub数据源独立为GitRepositoryManager
- **经验**：增量更新是必要的，架构独立有利于维护

**决策2：维基百科集成**
- 智能触发：当检索结果不足时自动补充
- 分区展示：知识库来源与维基百科来源分开
- **思考**：增强功能应该是"锦上添花"，不能干扰主流程

**决策3：UI重构**
- 多页面架构：主页（聊天）+ 设置页
- Claude风格：温暖米色系配色
- 侧边栏优化：历史会话、用户信息集中
- **原则**：UI改进要遵循"用户行为分析→优化→验证"

**决策4：RAG推理能力增强**
- Prompt优化：从"基于上下文"改为"结合专业知识推理"
- Temperature提升：QueryEngine 0.1→0.5，ChatManager 0.3→0.6
- 相似度阈值过滤：提示用户答案来源（检索 vs 推理）
- **发现**：Prompt设计是控制RAG行为的第一要素

#### 遇到的问题

**问题1：GPU加速配置**
- UV环境自动同步覆盖CUDA版本
- `uv run`默认会执行`uv sync`
- **解决**：所有`uv run`命令添加`--no-sync`选项
- **经验**：深入理解工具行为，不能假设

**问题2：索引持久化问题**
- Chroma持久化路径不一致
- 后台线程导致异常
- **经验**：数据持久化需要在设计阶段充分考虑

#### 经验总结

1. **架构独立优先** - 大功能模块应独立，便于测试和维护
2. **性能优化要有数据支撑** - 增量更新带来30倍提升
3. **UI改进遵循用户行为** - 不要凭感觉优化
4. **Prompt是第一要素** - 比模型参数更重要
5. **工具行为要深入理解** - UV的自动同步机制

#### 里程碑

- ✅ GitHub增量更新：30倍性能提升
- ✅ 维基百科智能补充
- ✅ UI重构：多页面+Claude风格
- ✅ 推理能力增强：平衡检索与推理
- ✅ GPU加速配置完成

---

### 阶段3: 生产部署（10月下旬）

**时间线**：2025-10-22 至 2025-10-31

#### 核心目标

准备生产环境部署，实现最小化PaaS配置。

#### 关键决策

**决策1：最小化部署策略**
- 数据暂不持久化（演示阶段可接受）
- Embedding模型启动时下载（5-10分钟）
- 单命令启动应用
- **理念**：快速上线收集反馈，优化后再完善

**决策2：部署平台选择**
- Zeabur优先：国内访问友好
- Railway备选：功能丰富
- **原则**：优先考虑用户访问体验

**决策3：可观测性集成**
- Phoenix可视化平台
- LlamaDebugHandler追踪
- **思考**：可观测性在生产环境至关重要

#### 遇到的问题

**问题1：批处理分组与E2E测试**
- 批处理逻辑复杂
- 测试覆盖不全
- **经验**：复杂的批处理逻辑要有充分测试

**问题2：Markdown格式化**
- 输出格式混乱
- 需要解析和格式化
- **经验**：输出格式化影响用户体验，不能忽视

#### 经验总结

1. **最小化原则** - 先上线再优化，不要过度设计
2. **国内访问友好** - 优先考虑用户体验
3. **可观测性是必需** - 生产环境需要可见性
4. **测试要充分** - 复杂逻辑必须有完整测试

#### 里程碑

- ✅ Docker化完成
- ✅ Zeabur部署就绪
- ✅ 可观测性集成（Phoenix）
- ✅ Markdown格式化

---

### 阶段4: 架构升级（11月初）

**时间线**：2025-11-01 起

#### 核心目标

从传统分层架构升级到模块化三层架构，提升可扩展性和可维护性。

#### 关键决策

**决策1：模块化三层架构**
```
前端层 → 业务层 → 基础设施层
```
- 协议驱动：IQueryEngine, IIndexer, IRetriever
- 流水线编排：PipelineExecutor
- 模块注册：ModuleRegistry
- **理念**：统一架构，渐进迁移

**决策2：可插拔模块**
- Embedding：本地模型 vs API模型
- Retriever：向量/BM25/混合/自动路由
- Reranker：SentenceTransformer vs BGE
- Observer：LlamaDebug vs Phoenix vs RAGAS
- **原则**：每个模块都要可替换

**决策3：渐进式迁移**
- P0: 统一服务接口（保持向后兼容）
- P1: 流水线编排
- P2: 模块注册中心
- P3: 事件钩子+策略管理
- **策略**：平滑迁移，不破坏现有功能

#### 遇到的问题

**问题1：代码拆分**
- 传统架构文件过大（如indexer.py 2124行）
- 需要按职责拆分
- **经验**：文件不超过300行是合理的

**问题2：向后兼容**
- 前端需要兼容新旧架构
- 兼容层设计复杂
- **经验**：迁移需要保留兼容层

#### 经验总结

1. **协议驱动架构** - 接口定义清晰，实现可替换
2. **渐进式迁移** - 平滑过渡，降低风险
3. **文件大小限制** - 300行是一个合理阈值
4. **向后兼容重要** - 迁移不能破坏现有功能

#### 里程碑

- ✅ 模块化三层架构设计完成
- ✅ Grep检索器实现
- ✅ 多策略检索框架完成
- ✅ Reranker模块完成
- ✅ RAGAS评估器集成
- ✅ 自动路由模式实现
- ✅ P0-P3迁移已完成

---

### 阶段5: 代码质量提升（12月）

**时间线**：2025-12-06 至 2025-12-20

#### 核心目标

全面提升代码质量，完善架构设计，优化用户体验和系统性能。

#### 关键决策

**决策1：三层架构重构**
- 明确分层：基础设施层 → 业务层 → 前端层
- 职责清晰：基础设施层无业务逻辑，业务层专注编排，前端层负责交互
- **经验**：架构分层要明确，职责边界要清晰

**决策2：结构化日志与类型安全**
- structlog全面迁移：替代标准logging，支持结构化日志
- Pydantic全面迁移：替代dataclass，提升类型安全和数据验证
- **策略**：激进迁移，完全移除向后兼容层
- **经验**：工程实践提升需要果断决策，向后兼容有时是负担

**决策3：代码优化与重构**
- 模块级优化：data_loader、rag_api、embeddings、ChatManager等
- 文件拆分：遵循300行限制，按职责拆分
- 导入优化：统一使用绝对导入，清理冗余依赖
- **原则**：持续重构，保持代码整洁

**决策4：UI架构改进**
- 弹窗化：设置和文件查看改为弹窗实现
- Material Design风格：聊天输入框采用Material Design
- 单页应用准备：为后续单页应用重构做准备
- **理念**：用户体验优先，简化交互流程

**决策5：部署与性能优化**
- Zeabur双服务分离：前端和后端服务分离部署
- 启动延迟优化：减少应用启动时间
- 流式输出优化：直接流式管道实现
- **目标**：提升生产环境体验

#### 遇到的问题

**问题1：架构迁移复杂度**
- 三层架构重构涉及大量文件移动和导入更新
- 需要保持功能完整性
- **解决**：分阶段迁移，先移动文件，再更新导入，最后优化代码

**问题2：向后兼容与激进迁移**
- 初始计划保留向后兼容层
- 用户要求激进迁移，完全移除兼容代码
- **经验**：有时需要果断决策，向后兼容可能是技术债务

**问题3：Embedding适配器问题**
- HFInferenceEmbedding适配器参数兼容性问题
- 类型不匹配导致初始化失败
- **经验**：第三方库适配需要充分测试，注意版本兼容性

#### 经验总结

1. **架构清晰优先** - 三层架构让代码组织更清晰，职责更明确
2. **工程实践提升** - structlog和Pydantic提升代码质量和可维护性
3. **持续重构** - 代码优化是持续过程，不要积累技术债务
4. **激进迁移有时更好** - 果断移除向后兼容层，避免维护负担
5. **用户体验优先** - UI改进要关注用户体验，简化交互流程

#### 里程碑

- ✅ 三层架构重构完成
- ✅ structlog和Pydantic全面迁移
- ✅ 代码优化和重构（多个模块）
- ✅ UI改进（弹窗化、Material Design）
- ✅ 部署优化（Zeabur双服务分离）
- ✅ 性能优化（启动延迟、流式输出）

---

### 阶段6: 前端架构统一（1月）

**时间线**：2026-01-01

#### 核心目标

统一前端代码组织，简化架构，提升可维护性。

#### 关键决策

**决策1：前端完全迁移**
- `src/ui/` → `frontend/`：前端代码统一到frontend目录
- 架构统一：所有前端代码集中管理
- **理念**：前端代码应该独立组织，与业务层和基础设施层分离

**决策2：单页应用重构**
- 移除`pages/`目录：Streamlit多页面架构改为单页应用
- 弹窗化所有功能：设置和文件查看通过弹窗实现
- **优势**：架构更统一，代码组织更清晰，用户体验更好
- **策略**：无需历史兼容，直接重构迁移

**决策3：代码重构与注释补充**
- chat.py代码重构：优化代码结构，补充完整注释
- 测试修复：前端测试修复与Mock配置优化
- **原则**：代码质量持续提升，文档同步更新

#### 遇到的问题

**问题1：Streamlit多页面限制**
- `pages/`目录必须在项目根目录，无法迁移到`frontend/`
- **解决**：改为单页应用，所有功能通过弹窗实现

**问题2：前端测试Mock配置**
- 前端测试需要Mock Streamlit组件
- **经验**：测试配置需要与实际使用保持一致

#### 经验总结

1. **架构统一重要** - 前端代码应该独立组织，统一管理
2. **简化优于复杂** - 单页应用比多页面应用更简单，维护成本更低
3. **弹窗化提升体验** - 弹窗实现比页面跳转更流畅，用户体验更好
4. **测试配置要准确** - Mock配置需要与实际使用保持一致

#### 里程碑

- ✅ 前端完全迁移到frontend目录
- ✅ 单页应用重构完成
- ✅ pages目录移除
- ✅ 代码重构与注释补充
- ✅ 前端测试修复

---

## 📊 当前状态

### 已实现的核心功能

#### 基础功能

- ✅ **引用溯源**：每个回答都标注具体的来源文档和段落
- ✅ **多轮对话**：支持上下文追问，智能理解对话历史
- ✅ **简洁界面**：基于 Streamlit 的单页应用，Material Design风格

#### 数据能力

- ✅ **多数据源**：Markdown文件、网页内容、GitHub仓库
- ✅ **维基百科增强**：自动补充背景知识，智能触发，分区展示来源
- ✅ **增量更新**：GitHub仓库增量更新（30倍性能提升）

#### 用户体验

- ✅ **自动持久化**：会话自动保存，刷新页面后恢复
- ✅ **历史会话**：侧边栏显示历史会话列表
- ✅ **弹窗化功能**：设置和文件查看通过弹窗实现，体验更流畅
- ✅ **Material Design**：聊天输入框采用Material Design风格

#### 开发调试

- ✅ **结构化日志**：structlog结构化日志，便于日志聚合和分析
- ✅ **类型安全**：Pydantic数据验证，提升API和内部数据流的类型安全
- ✅ **RAG可观测性**：Phoenix和LlamaDebugHandler集成
- ✅ **灵活配置**：支持本地embedding模型和API切换

### 技术架构现状

#### 架构演进

**当前阶段**：三层架构（基础设施层、业务层、前端层）

**三层架构**：
1. **前端层**：`app.py` → `frontend/main.py`，单页应用，弹窗化功能
2. **业务层**：`src/business/` - RAGService, PipelineExecutor, StrategyManager, ContextManager
3. **基础设施层**：`src/infrastructure/` - Retriever, Reranker, Embedding, Observer, Indexer, DataLoader

**核心特性**：
- 协议驱动：接口清晰，实现可替换
- 流水线编排：PipelineExecutor统一管理
- 模块注册：ModuleRegistry集中管理
- 事件钩子：HookManager支持扩展
- 结构化日志：structlog统一日志格式
- 类型安全：Pydantic数据验证

#### 可插拔模块

| 模块 | 实现选项 | 状态 |
|------|---------|------|
| **Embedding** | Local (BGE) / API (HF Inference) | ✅ |
| **Retriever** | Vector / BM25 / Hybrid / Auto / Grep | ✅ |
| **Reranker** | SentenceTransformer / BGE | ✅ |
| **Observer** | LlamaDebug / Phoenix / RAGAS | ✅ |
| **Parser** | Markdown / PDF | ✅ |

#### 部署状态

- ✅ Docker化完成
- ✅ Zeabur双服务分离部署
- ✅ Railway配置完成
- ✅ 启动延迟优化
- ✅ 流式输出优化

### 项目指标

#### 代码规模

- **源代码文件**：约 120+ 个文件
- **测试文件**：约 110+ 个测试用例
- **文档**：核心文档 + 150+ 任务日志

#### 测试覆盖率

- **单元测试**：约 60+ 个
- **集成测试**：约 15+ 个
- **性能测试**：约 13+ 个
- **前端测试**：约 20+ 个

#### 性能指标

- **查询响应**：3-5秒（含LLM调用）
- **引用准确率**：>90%
- **GPU加速**：约6倍性能提升
- **增量更新**：30倍性能提升
- **启动延迟**：已优化

---

## 🔮 未来方向探索

### 短期方向（1-2个月）

#### 高优先级

1. **生产环境优化** ⭐⭐⭐
   - Zeabur数据持久化
   - 安全加固
   - 监控告警
   - 性能优化

2. **回答质量优化** ⭐⭐⭐
   - 检索精度提升
   - Prompt工程优化
   - 用户反馈机制

3. **PDF解析优化** ⭐⭐⭐
   - Tesseract/Unstructured/DeepSeek OCR
   - 多方案评估
   - 性能对比

#### 中优先级

4. **Embedding模型评估** ⭐⭐
   - MTEB评估
   - 模型对比
   - 可插拔架构优化

5. **重排序策略优化** ⭐⭐
   - Re-ranking策略
   - 检索评估
   - 精度提升

6. **UI/UX优化** ⭐⭐
   - 移动端适配
   - 暗色模式
   - 快捷键支持

### 中期方向（3-6个月）

1. **RAG架构演进**
   - 模块化 → Agentic RAG
   - 自适应RAG
   - 纠错机制
   - 分阶段演进

2. **评估体系构建**
   - Phoenix集成完成
   - RAGAS评估完整化
   - deep EVAL集成
   - 全方位评估

3. **数据清洗与质量管控**
   - 清洗流程自动化
   - 质量标准建立
   - 批量验证

4. **模型优化与本地部署**
   - 量化/剪枝/蒸馏
   - API+本地双模式
   - 成本优化

### 长期愿景（待探索）

1. **垂直领域知识图谱**
   - 系统科学知识图谱
   - 实体关系抽取
   - 知识推理

2. **多模态RAG**
   - 图像识别
   - 表格理解
   - 混合模态检索

3. **协作功能**
   - 多人共享知识库
   - 注释与评论
   - 知识贡献机制

4. **高级检索**
   - 时间线检索
   - 概念图谱
   - 相似性分析

**说明**：这些方向还在探索中，会随实践调整。

---

## 💡 方法论总结

### 技术决策原则

#### 1. 最小化原则

**核心思想**：从简单开始，渐进式完善

**实践**：
- MVP先上线，再优化
- 架构先可运行，再模块化
- 功能先可用，再精致

**案例**：
- 生产部署：数据先不持久化，验证可行后再完善
- 架构迁移：先独立模块，再逐步集成

#### 2. 向后兼容优先

**核心思想**：不破坏现有功能

**实践**：
- 新架构保留旧接口
- 兼容层隔离变化
- 渐进式迁移

**案例**：
- ModularQueryEngine与QueryEngine并存
- HybridQueryEngineWrapper兼容层

#### 3. 协议驱动架构

**核心思想**：接口清晰，实现可替换

**实践**：
- 先定义接口（协议）
- 再实现具体类
- 模块可插拔

**案例**：
- IRetriever, IReranker, IEmbedding
- 可替换实现不影响上层

#### 4. 数据驱动优化

**核心思想**：用数据说话，不要凭感觉

**实践**：
- 性能优化要有基准
- UI改进要有用户反馈
- A/B测试验证效果

**案例**：
- 增量更新30倍提升（有数据）
- Temperature调整有理论支撑

#### 5. 测试优先

**核心思想**：测试是质量的保障

**实践**：
- 先写测试，再实现功能
- Mock隔离外部依赖
- 单元+集成+性能全覆盖

**案例**：
- 88个测试用例（MVP）
- 模块化后测试覆盖率>80%

### 实践中的经验

#### 经验1：Agent Task Log的价值

**发现**："在做的时候不觉得有用，但未来需要总结时提供数据支撑"

**实践**：
- 每个任务都有详细记录
- 记录思考过程、失败尝试、关键决策
- 便于回顾和反思

**价值**：
- ✅ 可追溯：知道做了什么
- ✅ 可学习：理解思考过程
- ✅ 可复用：避免重复踩坑
- ✅ 可改进：优化人机协作

#### 经验2：从实践中总结方法论

**理念**：从实践中总结经验，而非有一个完美蓝图再去执行

**实践**：
- 先做再总结
- 发现规律后抽象
- 方法论迭代演进

**案例**：
- AGENTS.md的演进：从自然语言到结构化规则
- 模块化设计：从耦合到协议驱动

#### 经验3：技术的本质是解决问题

**理念**：技术选型服务于目标，不是炫技

**实践**：
- 优先成熟方案（LlamaIndex vs 自研）
- 平衡复杂度与收益
- 避免过度设计

**案例**：
- Chroma而非Qdrant（本地优先）
- Streamlit而非自定义（快速迭代）

#### 经验4：用户行为分析指导优化

**理念**：UI改进要有数据支撑，不要凭感觉

**实践**：
- 观察用户操作流程
- 识别痛点
- 针对性优化

**案例**：
- 历史会话侧边栏：用户经常切换会话
- 设置页独立：避免主页复杂度

#### 经验5：演进式架构

**理念**：架构不是一成不变的，要随需求演进

**实践**：
- Phase 1: 传统分层（快速验证）
- Phase 2: 局部模块化（按需改进）
- Phase 3: 模块化三层（系统升级）

**案例**：
- 从耦合到协议驱动
- 从固定流程到流水线编排

### 反思与思考

#### 思考1：关于日志记录

**发现**：Agent Task Log非常有价值，现在用来总结路线图

**反思**：
- 记录日志是"延迟满足"
- 当下看不到价值，但未来需要时很有用
- 这是一种"投资"思维

**应用**：
- 继续保持详细的任务日志
- 定期回顾和总结
- 将经验沉淀为方法论

#### 思考2：关于人机协作

**发现**：人机协作的价值在于明确分工

**思考**：
- Human: 决策、架构、边界思考
- Agent: 执行、细节实现、错误诊断
- 关键是找到平衡点

**经验**：
- 决策原则：Human应该介入的时刻
- 协作要点：Agent应该自主完成的任务
- 效率优化：批量处理，减少来回

#### 思考3：关于技术与业务

**发现**：技术是为业务服务的，不是炫技

**思考**：
- RAG技术在垂直领域的应用价值
- 系统科学的数字化、智能化
- 方法论与实践的平衡

**未来方向**：
- 深入垂直领域（系统科学）
- 探索AI与系统工程的结合
- 积累领域知识和方法论

#### 思考4：关于演进与稳定

**发现**：架构需要演进，但不能破坏稳定

**思考**：
- 如何平衡演进与稳定？
- 向后兼容是关键
- 渐进式迁移是策略

**经验**：
- 协议驱动架构降低耦合
- 兼容层隔离变化
- 分阶段验证

#### 思考5：关于未来

**发现**：项目的未来方向还在探索中

**思考**：
- 知识图谱 vs 多模态RAG vs Agentic RAG
- 垂直领域深入 vs 功能扩展
- 方法论总结 vs 技术实现

**策略**：
- 保持探索心态
- 根据实践调整方向
- 继续记录和总结

---

## 📚 相关资源

### 核心文档

- [文档中心](README.md) - 文档导航和索引
- [架构设计](ARCHITECTURE.md) - 模块化三层架构
- [项目追踪](TRACKER.md) - 任务管理与进度追踪
- [AI Agent 协作指南](../AGENTS.md) - 协作规范与要点

### 任务记录

- [任务归档](../agent-task-log/README.md) - 完整任务记录
- [模块化实施总结](../agent-task-log/2025-11-01-32_【documentation】模块化RAG架构实施-完整完成总结.md)
- [RAG推理增强](../agent-task-log/2025-10/2025-10-14-1_【implementation】RAG推理能力增强-详细过程.md)

---

**最后更新**: 2026-01-01  
**维护者**: 项目团队  
**文档定位**: 宏观路线图，记录演进历程和方法论总结

